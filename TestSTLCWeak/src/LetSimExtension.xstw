module LetSimExtension;

import LetSeqExtension;

// extension {
//   context-free syntax
//     "let" SimBindings "in" Term -> Term {cons("LetSim")}

//   context-free syntax
//     Binding "|" Binding     -> SimBindings
//     Binding "|" SimBindings -> SimBindings

//   context-free priorities
//     { Term Term                   -> Term
//       Term "+" Term               -> Term } >
//       "let" SimBindings "in" Term -> Term

//   inductive definitions
//     T-LetSim1:
//       (C |- t1 : T1) (C |- t2 : T2) (C,x1:T1,x2:T2 |- t : T)
//       ------------------------------------------------------
//       C |- let x1 = t1 | x2 = t2 in t : T
//     T-LetSim2:
//       (C |- t1 : T1) (C |- t2 : T2) (C |- t3 : T3) (C,x1:T1,x2:T2,x3:T3 |- t : T)
//       ---------------------------------------------------------------------------
//       C |- let x1 = t1 | x2 = t2 | x3 = t3 in t : T
//     T-LetSim3:
//       (C |- t1 : T1) (C |- t2 : T2) (C |- t3 : T3) (C |- t4 : T4) (C,x1:T1,x2:T2,x3:T3,x4:T4 |- t : T)
//       ------------------------------------------------------------------------------------------------
//       C |- let x1 = t1 | x2 = t2 | x3 = t3 | x4 = t4 in t : T

//   desugarings
//     { (C |- t1 : T1) (C |- t2 : T2) (C,x1:T1,x2:T2 |- t : T)
//       ------------------------------------------------------
//       C |- [ let x1 = t1 | x2 = t2 in t ] : T
//       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>
//       (\x1:T1.\x2:T2. t) t1 t2 }
//     { (C |- t1 : T1) (C |- t2 : T2) (C |- t3 : T3) (C,x1:T1,x2:T2,x3:T3 |- t : T)
//       ---------------------------------------------------------------------------
//       C |- [ let x1 = t1 | x2 = t2 | x3 = t3 in t ] : T
//       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>
//       (\x1:T1.\x2:T2.\x3:T3. t) t1 t2 t3 }
//     { (C |- t1 : T1) (C |- t2 : T2) (C |- t3 : T3) (C |- t4 : T4) (C,x1:T1,x2:T2,x3:T3,x4:T4 |- t : T)
//       ------------------------------------------------------------------------------------------------
//       C |- [ let x1 = t1 | x2 = t2 | x3 = t3 | x4 = t4 in t ] : T
//       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>
//       (\x1:T1.\x2:T2.\x3:T3.\x4:T4. t) t1 t2 t3 t4 }
// }


extension {
  context-free syntax
    "args" "(" SimBindings "," Term ")" -> Term {sx-aux}
    "body" "(" SimBindings "," Term ")" -> Term {sx-aux}

  context-free syntax
    "let" SimBindings "in" Term -> Term {cons("LetSim")}

  context-free syntax
    Binding "|" Binding     -> SimBindings
    Binding "|" SimBindings -> SimBindings

  context-free priorities
    { Term Term                   -> Term
      Term "+" Term               -> Term } >
      "let" SimBindings "in" Term -> Term

  inductive definitions
    T-LetSim1:
      C |- args(sbs, body(sbs, t)) : T
      --------------------------------
      C |- let sbs in t : T

    T-LetSim2:
      (C |- t1 : T1) (C,x:T1 |- t2 : T2)
      ----------------------------------
      C |- body(x1 = t1, t2) : T1 -> T2
    T-LetSim3:
      (C |- t1 : T1) (C,x:T1 |- body(sbs, t2) : T2)
      ---------------------------------------------
      C |- body(x1 = t1 | sbs, t2) : T1 -> T2
    T-LetSim4:
      (C |- t1 : T1) (C |- t2 : T1 -> T2)
      -----------------------------------
      C |- args(x1 = t1, t2) : T2
    T-LetSim5:
      C |- args(bs, t2 t1) : T
      -------------------------------
      C |- args(x1 = t1 | bs, t2) : T

  desugarings
    { let sbs in t ~~~> args(sbs, body(sbs, t)) }

    { args(x1 = t1, t2) ~~~> t2 t1 }

    { args(x1 = t2 | bs, t2) ~~~> args(bs, t2 t1) }

    { (C |- t1 : T1) (C,x:T1 |- t2 : T2)
      ----------------------------------
      body(x1 = t1, t2)
      ~~~~~~~~~~~~~~~~~>
      \x1:T1. t2 }

    { (C |- t1 : T1) (C,x:T1 |- body(sbs, t2) : T2)
      ---------------------------------------------
      body(x1 = t1 | sbs, t2)
      ~~~~~~~~~~~~~~~~~~~~~~~>
      \x1:T1. body(sbs, t2) }
}